<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#F7F9F7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>MochiDrop ‚ö°Ô∏è</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/3750/3750019.png">
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@500;600;700&display=swap');
        
        :root {
            --bg-page: #F7F9F7; --bg-card: #FFFFFF; --text-main: #2C3E50; --text-sub: #95A5A6;
            --accent-primary: #76A665; --accent-light: #E8F5E9; --accent-hover: #639252;
            --radius-card: 24px; --radius-btn: 16px;
            --shadow-float: 0 15px 35px -5px rgba(118, 166, 101, 0.15), 0 5px 15px -8px rgba(0,0,0,0.05);
            --chat-bubble-self: #76A665; --chat-bubble-friend: #FFFFFF;
        }

        body { 
            font-family: 'Quicksand', sans-serif; background-color: var(--bg-page); color: var(--text-main);
            margin: 0; display: flex; flex-direction: column; align-items: center; 
            min-height: 100vh; overflow-x: hidden; -webkit-tap-highlight-color: transparent; 
            padding-top: 80px; padding-bottom: 40px;
        }

        /* --- UI Âü∫Á°ÄÁªÑ‰ª∂ --- */
        .navbar { position: fixed; top: 0; left: 0; width: 100%; height: 64px; background: rgba(247, 249, 247, 0.95); backdrop-filter: blur(12px); display: flex; align-items: center; justify-content: center; z-index: 1000; box-shadow: 0 1px 0 rgba(0,0,0,0.05);}
        .navbar-title { font-family: 'Fredoka One', cursive; color: var(--accent-primary); font-size: 1.4rem; display: flex; align-items: center; gap: 8px; }
        .navbar-icon { width: 32px; height: 32px; }
        .card { width: 88%; max-width: 420px; background: var(--bg-card); border-radius: var(--radius-card); padding: 24px; box-shadow: var(--shadow-float); margin-bottom: 24px; transition: transform 0.2s; }
        .card-label { font-size: 0.75rem; color: var(--text-sub); font-weight: 700; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 16px; display: block; text-align: left; }
        
        /* Ë∫´‰ªΩ & ËøûÊé• */
        .identity-layout { display: flex; align-items: center; gap: 20px; }
        .qr-container { flex-shrink: 0; width: 100px; height: 100px; background: var(--bg-page); border-radius: 18px; padding: 8px; display: flex; align-items: center; justify-content: center; }
        #qrcode img { display: block; width: 100%; height: auto; }
        .info-container { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; text-align: left; overflow: hidden; }
        .id-label { font-size: 0.8rem; color: var(--text-sub); margin-bottom: 4px; }
        .id-value { font-family: 'Quicksand', monospace; font-size: 1.2rem; font-weight: 700; color: var(--text-main); word-break: break-all; line-height: 1.3; }
        .status-badge { display: inline-flex; align-items: center; gap: 6px; margin-top: 8px; font-size: 0.75rem; color: var(--accent-primary); font-weight: 600; background: var(--accent-light); padding: 4px 10px; border-radius: 20px; align-self: flex-start; }
        .status-dot { width: 8px; height: 8px; background: var(--accent-primary); border-radius: 50%; animation: blink 2s infinite;}
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }

        .input-wrapper { position: relative; margin-bottom: 12px; display: flex; align-items: center; background: var(--bg-page); border-radius: var(--radius-btn); padding: 4px 6px 4px 16px; border: 1px solid #eee; }
        input[type="text"] { flex: 1; border: none; background: transparent; outline: none; font-size: 1rem; font-weight: 600; color: var(--text-main); padding: 12px 0; }
        .btn-scan-mini { width: 40px; height: 40px; border-radius: 12px; background: #FFF; border: none; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; }
        .btn-primary { width: 100%; padding: 16px; border: none; border-radius: var(--radius-btn); background: var(--accent-primary); color: white; font-size: 1rem; font-weight: 700; cursor: pointer; box-shadow: 0 4px 15px rgba(118, 166, 101, 0.4); transition: 0.2s; }
        .btn-primary:active { transform: scale(0.98); background: var(--accent-hover); }
        #btn-save-friend { display: none; margin-top: 10px; background: #F9C74F; color: #FFF; border:none; padding: 10px; border-radius: 12px; width: 100%; font-weight: 700; cursor: pointer; }

        /* Â•ΩÂèãÂàóË°® */
        .friend-list { list-style: none; padding: 0; margin: 0; }
        .friend-item { display: flex; align-items: center; padding: 12px; background: var(--bg-page); border-radius: 16px; margin-bottom: 10px; cursor: pointer; border: 2px solid transparent;}
        .friend-item.active { border-color: var(--accent-primary); background: #F0F9F0; }
        .friend-name { font-weight: 700; font-size: 0.95rem; flex: 1; margin-left: 10px;}
        .btn-icon-small { width: 30px; height: 30px; border-radius: 50%; border: none; cursor: pointer; background: #FFF; color: #999; }

        /* ‰º†Ëæì‰∏ªÁïåÈù¢ */
        .upload-zone { border: 2px dashed #D6E4D0; border-radius: var(--radius-card); background: #FAFCFA; padding: 40px 20px; cursor: pointer; display: flex; flex-direction: column; align-items: center; transition: 0.3s; }
        .file-list { list-style: none; padding: 0; margin: 20px 0 0 0; max-height: 250px; overflow-y: auto;}
        .file-item { display: flex; align-items: center; gap: 12px; padding: 12px; border-bottom: 1px solid #F0F0F0; }
        .file-name { flex: 1; font-size: 0.9rem; font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: left;}
        .file-status { font-size: 0.75rem; color: var(--text-sub); font-family: monospace; white-space: nowrap;}
        .file-item.done .file-status { color: var(--accent-primary); font-weight: bold; }
        .download-btn { display: inline-flex; align-items: center; gap: 5px; background: #E8F5E9; border: 1px solid var(--accent-primary); color: var(--accent-primary); padding: 6px 12px; border-radius: 8px; text-decoration: none; font-weight: 700; font-size: 0.8rem; cursor: pointer;}

        /* ËÅäÂ§©ÊÇ¨ÊµÆ‰∏éÁ™óÂè£ */
        #fab-wrapper { position: fixed; bottom: 30px; right: 30px; z-index: 1500; display: none; flex-direction: column; align-items: flex-end; }
        #fab-chat { width: 60px; height: 60px; border-radius: 30px; background: var(--accent-primary); color: white; box-shadow: 0 10px 25px rgba(118, 166, 101, 0.4); border: none; cursor: pointer; font-size: 1.8rem; display: flex; align-items: center; justify-content: center; transition: transform 0.2s; }
        #fab-chat:active { transform: scale(0.9); }
        #fab-toast { background: #2C3E50; color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.85rem; font-weight: 700; margin-bottom: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: none; position: absolute; right: 0; bottom: 70px; white-space: nowrap; }
        .animate-pulse { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(118, 166, 101, 0.7); } 70% { box-shadow: 0 0 0 15px rgba(118, 166, 101, 0); } 100% { box-shadow: 0 0 0 0 rgba(118, 166, 101, 0); } }

        #chat-modal { position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; align-items: flex-end; justify-content: center; }
        .chat-container { width: 100%; max-width: 500px; height: 85vh; background: #F2F4F2; border-radius: 24px 24px 0 0; display: flex; flex-direction: column; box-shadow: 0 -10px 40px rgba(0,0,0,0.2); overflow: hidden; animation: slideUp 0.3s ease-out; }
        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        
        .chat-header { padding: 15px 20px; background: #FFF; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #E0E0E0;}
        .chat-title { font-weight: 700; color: var(--text-main); font-size: 1.1rem; }
        .btn-close-chat { background: #F5F5F5; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-weight: bold; color: #666;}
        
        .chat-messages { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; }
        .message { max-width: 80%; padding: 12px 16px; border-radius: 18px; font-size: 0.95rem; line-height: 1.4; word-break: break-word; position: relative; box-shadow: 0 1px 3px rgba(0,0,0,0.05);}
        .msg-self { align-self: flex-end; background: var(--chat-bubble-self); color: white; border-bottom-right-radius: 4px; }
        .msg-friend { align-self: flex-start; background: var(--chat-bubble-friend); color: var(--text-main); border-bottom-left-radius: 4px; }
        
        .msg-img { max-width: 200px; border-radius: 12px; cursor: zoom-in; display: block; background: #eee; margin-top: 5px;}
        .file-bubble { display: flex; flex-direction: column; gap: 5px; min-width: 180px; }
        .file-bubble-info { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 0.9rem; }
        .chat-progress-bg { width: 100%; height: 4px; background: rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden; margin-top: 5px;}
        .chat-progress-fill { height: 100%; width: 0%; background: rgba(255,255,255,0.8); transition: width 0.2s; }
        .msg-friend .chat-progress-fill { background: var(--accent-primary); }
        .file-meta { font-size: 0.7rem; opacity: 0.8; text-align: right; margin-top: 4px; font-family: monospace;}

        .chat-footer { padding: 12px; background: #FFF; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid #E0E0E0;}
        .chat-input-row { display: flex; align-items: center; gap: 8px; }
        .chat-input { flex: 1; padding: 12px 15px; border-radius: 20px; border: 1px solid #EEE; outline: none; background: #F9F9F9; height: 46px; box-sizing: border-box; font-size: 1rem; }
        .chat-btn-icon { width: 40px; height: 40px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; background: #F0F0F0; color: #555; transition: 0.2s; flex-shrink: 0;}
        .btn-send-chat { background: var(--accent-primary); color: white; }
        .emoji-picker { display: none; grid-template-columns: repeat(8, 1fr); gap: 5px; padding: 10px; background: #F9F9F9; border-radius: 12px; max-height: 150px; overflow-y: auto; margin-bottom: 5px;}
        .emoji-item { font-size: 1.4rem; cursor: pointer; text-align: center; padding: 5px; border-radius: 5px; }

        #status-toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(44, 62, 80, 0.9); color: white; padding: 12px 24px; border-radius: 50px; font-size: 0.9rem; font-weight: 600; box-shadow: 0 10px 30px rgba(0,0,0,0.15); backdrop-filter: blur(10px); display: none; z-index: 2000; white-space: nowrap; }
        #scan-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(25px); z-index: 9999; display: none; flex-direction: column; align-items: center; justify-content: center; }
        #reader { width: 80vw; max-width: 350px; border-radius: 24px; overflow: hidden; box-shadow: 0 20px 60px rgba(0,0,0,0.2); }
        .btn-close-scan { margin-top: 40px; width: 50px; height: 50px; border-radius: 50%; background: #F1F1F1; color: #333; border: none; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        #lightbox { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 3000; display: none; align-items: center; justify-content: center; }
        #lightbox img { max-width: 95%; max-height: 95%; border-radius: 8px; }
        .close-lb { position: absolute; top: 20px; right: 20px; color: white; font-size: 2rem; cursor: pointer; padding: 20px;}
    </style>
</head>
<body onclick="unlockAudio()">

    <audio id="silent-audio" loop><source src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//oeAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD//////////////////////////////////////////////////////////////////wAAAP//OgAAAAAAAABMYXZjNTguMTM0LjEwMAAAAAAAAAAAAAAA//oeAAAAAAABIAAAAAAAAAAAAAAA//oeAAAAAAAAAAAAAAAAAAAAAAA=" type="audio/mpeg"></audio>

    <div class="navbar">
        <div class="navbar-title"><img src="https://cdn-icons-png.flaticon.com/512/3750/3750019.png" class="navbar-icon"> SlothDrop</div>
    </div>

    <div class="card">
        <span class="card-label">MY IDENTITY</span>
        <div class="identity-layout">
            <div class="qr-container" id="qrcode"></div>
            <div class="info-container">
                <div class="id-label">Device ID</div>
                <div class="id-value" id="my-id">Connecting...</div>
                <div class="status-badge"><span class="status-dot"></span><span id="connection-status">Init...</span></div>
            </div>
        </div>
    </div>

    <div class="card" id="friends-panel">
        <span class="card-label">SAVED DEVICES</span>
        <ul class="friend-list" id="friends-list">
            <li style="text-align:center; padding:10px; color:#999; font-size:0.85rem;">No saved devices yet.</li>
        </ul>
    </div>

    <div class="card" id="connect-panel">
        <span class="card-label">CONNECT DEVICE</span>
        <div class="input-wrapper">
            <input type="text" id="friend-id" placeholder="Enter ID to connect" autocomplete="off">
            <button class="btn-scan-mini" onclick="startScan()">üì∑</button>
        </div>
        <button class="btn-primary" onclick="connectToFriend()">Connect Now</button>
        <button id="btn-save-friend" onclick="saveCurrentFriend()">‚≠êÔ∏è Save This Device</button>
    </div>

    <div class="card" id="transfer-panel" style="display:none;">
        <span class="card-label">TRANSFER (Drag Files Here)</span>
        <div id="send-section">
            <label for="file-input" class="upload-zone" id="drop-zone">
                <div class="upload-icon">üìÇ</div>
                <div class="upload-text">Click or Drag Files Here</div>
            </label>
            <input type="file" id="file-input" style="display:none" multiple onchange="handleFileSelect(this)">
            
            <ul id="queue-list" class="file-list"></ul>
            
            <button class="btn-primary" onclick="processQueue()" id="send-btn" style="display:none; margin-top:20px;">Send Files üöÄ</button>
        </div>
        <div id="receive-section" style="display:none; margin-top:20px;">
             <span class="card-label" style="color:var(--accent-primary)">RECEIVED FILES</span>
             <ul id="received-list" class="file-list"></ul>
        </div>
    </div>

    <div id="fab-wrapper">
        <div id="fab-toast">New Message!</div>
        <button id="fab-chat" onclick="toggleChat()">üí¨</button>
    </div>

    <div id="chat-modal">
        <div class="chat-container">
            <div class="chat-header">
                <div class="chat-title">üí¨ Chat</div>
                <button class="btn-close-chat" onclick="toggleChat()">‚úï</button>
            </div>
            <div class="chat-messages" id="chat-messages">
                <div style="text-align:center; color:#999; font-size:0.8rem; margin-top:20px;">Connected. High speed enabled.</div>
            </div>
            <div class="chat-footer">
                <div class="emoji-picker" id="emoji-picker"></div>
                <div class="chat-input-row">
                    <button class="chat-btn-icon" onclick="document.getElementById('chat-file-input').click()">üìé</button>
                    <button class="chat-btn-icon" onclick="toggleEmoji()">üòä</button>
                    <input type="text" class="chat-input" id="chat-input" placeholder="Type..." autocomplete="off">
                    <button class="chat-btn-icon btn-send-chat" onclick="sendTextMessage()">‚û§</button>
                </div>
                <input type="file" id="chat-file-input" style="display:none" multiple onchange="handleChatFileSelect(this)">
            </div>
        </div>
    </div>

    <div id="lightbox" onclick="this.style.display='none'"><div class="close-lb">‚úï</div><img id="lightbox-img" src=""></div>
    <div id="status-toast"></div>
    <div id="scan-overlay"><div id="reader"></div><button class="btn-close-scan" onclick="stopScan()">‚úï</button></div>

    <script>
        // --- V3.0 Speed Core ---
        let peer = null; let conn = null; let html5QrCode = null; 
        // üöÄ Speed Boost: 64KB Chunks (WebRTC Optimized)
        const CHUNK_SIZE = 64 * 1024; 
        // Higher buffer cap for smoother flow
        const MAX_BUFFERED_AMOUNT = 256 * 1024; 
        
        let sendQueue = []; let wakeLock = null; let heartbeatTimer = null; 
        let currentConnectedPeerId = null;
        
        // Map to store active transfers { uuid: { meta, progress, type... } }
        let activeTransfers = {};

        const ui = {
            myId: document.getElementById('my-id'), toast: document.getElementById('status-toast'),
            statusText: document.getElementById('connection-status'),
            panels: { connect: document.getElementById('connect-panel'), transfer: document.getElementById('transfer-panel') },
            scan: { overlay: document.getElementById('scan-overlay') },
            input: document.getElementById('friend-id'),
            send: { btn: document.getElementById('send-btn'), list: document.getElementById('queue-list'), section: document.getElementById('send-section') },
            receive: { section: document.getElementById('receive-section'), list: document.getElementById('received-list') },
            dropZone: document.getElementById('drop-zone'),
            fabWrapper: document.getElementById('fab-wrapper'), fabChat: document.getElementById('fab-chat'), fabToast: document.getElementById('fab-toast'),
            chatModal: document.getElementById('chat-modal'), chatMessages: document.getElementById('chat-messages'),
            chatInput: document.getElementById('chat-input'), emojiPicker: document.getElementById('emoji-picker'),
            lightbox: document.getElementById('lightbox'), lightboxImg: document.getElementById('lightbox-img'),
            audio: document.getElementById('silent-audio'),
            btnSave: document.getElementById('btn-save-friend'), friendsList: document.getElementById('friends-list')
        };

        // --- Init ---
        try {
            peer = new Peer(null, { debug: 1 });
            peer.on('open', id => {
                ui.myId.innerText = id; ui.statusText.innerText = "Online";
                setTimeout(() => { new QRCode(document.getElementById("qrcode"), { text: id, width: 84, height: 84, colorDark : "#2C3E50", colorLight : "#F7F9F7", correctLevel : QRCode.CorrectLevel.L }); }, 200);
                renderFriendsList();
            });
            peer.on('error', err => { showToast("Net Error: " + err.type); ui.statusText.innerText = "Offline"; });
            peer.on('connection', c => { conn = c; setupConnection(); });
        } catch(e) { alert("Init Failed"); }

        function unlockAudio() { ui.audio.play().catch(()=>{}); document.body.onclick = null; }
        function playNotification() { 
            try { const ctx = new (window.AudioContext || window.webkitAudioContext)(); const o = ctx.createOscillator(); const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination); o.frequency.value=800; g.gain.value=0.1; o.start(); o.stop(ctx.currentTime+0.2); } catch(e){}
            if(navigator.vibrate) navigator.vibrate(200);
        }
        function notifyUser(msg) {
            if (ui.chatModal.style.display === 'none') { playNotification(); ui.fabToast.innerText = msg; ui.fabToast.style.display = 'block'; document.getElementById('fab-chat').classList.add('animate-pulse'); }
        }

        function setupConnection() {
            conn.on('open', () => { 
                showToast("Connected!"); ui.statusText.innerText = "Linked";
                ui.panels.connect.style.display = 'block'; ui.panels.transfer.style.display = 'block';
                ui.fabWrapper.style.display = 'flex';
                currentConnectedPeerId = conn.peer;
                ui.btnSave.style.display = "block"; ui.btnSave.innerText = isFriend(conn.peer) ? "‚úÖ Saved" : "‚≠êÔ∏è Save Device";
                updateFriendStatus(conn.peer, true);
                if(heartbeatTimer) clearInterval(heartbeatTimer);
                heartbeatTimer = setInterval(() => { if(conn?.open) conn.send({type: 'ping'}); }, 1000);
            });
            conn.on('close', () => { showToast("Disconnected"); updateFriendStatus(currentConnectedPeerId, false); setTimeout(() => location.reload(), 2000); });
            conn.on('data', handleDataReceived);
        }

        // --- V3.0 Unified Data Engine ---
        let incomingFile = { buffer: [], receivedSize: 0, meta: null, fileId: null, startTime: 0 };
        
        function handleDataReceived(data) {
            if (data.type === 'ping') return;

            // 1. Binary Chunks
            if (data instanceof ArrayBuffer || data instanceof Uint8Array) {
                if(!incomingFile.meta) return;
                const chunk = new Uint8Array(data);
                incomingFile.buffer.push(chunk); // Store as Uint8Array directly
                incomingFile.receivedSize += chunk.byteLength;
                
                // Throttle UI Updates (every 500ms or finish)
                const now = Date.now();
                if (now - incomingFile.lastUpdate > 500 || incomingFile.receivedSize === incomingFile.meta.fileSize) {
                    const duration = (now - incomingFile.startTime) / 1000;
                    const speed = duration > 0 ? (incomingFile.receivedSize / duration) : 0;
                    const progress = Math.min(100, Math.floor((incomingFile.receivedSize / incomingFile.meta.fileSize) * 100));
                    const speedStr = formatSpeed(speed);
                    
                    if (incomingFile.meta.fromChat) updateChatProgress(incomingFile.fileId, progress, speedStr);
                    else updateMainListProgress(incomingFile.fileId, progress, speedStr);
                    
                    incomingFile.lastUpdate = now;
                }
            } 
            // 2. Control Signals
            else if (data.type) {
                if (data.type === 'header') {
                    // Reset Buffer
                    incomingFile.buffer = []; incomingFile.receivedSize = 0; incomingFile.meta = data;
                    incomingFile.fileId = data.fileId || Date.now();
                    incomingFile.startTime = Date.now(); incomingFile.lastUpdate = Date.now();
                    
                    requestWakeLock();
                    
                    if (data.fromChat) {
                        createFileBubble(incomingFile.fileId, data.fileName, 'friend');
                        notifyUser("Receiving File...");
                    } else {
                        // Add to main list with specific ID
                        ui.receive.section.style.display = 'block';
                        addReceiveListItem(data.fileName, incomingFile.fileId); 
                        showToast(`Receiving: ${data.fileName}`);
                    }
                } 
                else if (data.type === 'end') {
                    // Assemble Blob
                    const blob = new Blob(incomingFile.buffer, { type: incomingFile.meta.fileType || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    
                    if (incomingFile.meta.fromChat) {
                        finishFileBubble(incomingFile.fileId, url, incomingFile.meta.fileName, incomingFile.meta.fileType, false);
                        notifyUser("File Received!");
                    } else {
                        finishReceiveListItem(incomingFile.fileId, url, incomingFile.meta.fileName);
                        showToast("Download Ready");
                    }
                    
                    incomingFile.buffer = []; incomingFile.meta = null; releaseWakeLock();
                }
                else if (data.type === 'chat-text') {
                    appendMessage(data.text, 'friend'); notifyUser("New Message");
                }
            }
        }

        // --- V3.0 Robust Sending ---
        async function transferFileUnified(file, isChat) {
            const fileId = generateUUID();
            
            // Setup UI elements via ID
            if (isChat) {
                createFileBubble(fileId, file.name, 'self');
            } else {
                // For main list, element is already created, we need to map the random ID to it?
                // Better: Update the logic to bind file object with ID
            }
            
            // If main list, find the LI and assign ID
            if (!isChat) {
                // We assume the file is at the top of queue or we passed the element ID? 
                // Simplifying: Main list updates are visual only for sender
            }
            
            conn.send({ type: 'header', fileName: file.name, fileType: file.type, fileSize: file.size, fromChat: isChat, fileId: fileId });
            
            let offset = 0;
            const startTime = Date.now();
            let lastUpdate = 0;
            
            while (offset < file.size) {
                // Smart Flow Control (No artificial delay unless full)
                if (conn.dataChannel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
                    await new Promise(r => setTimeout(r, 10)); // Wait 10ms
                    continue; 
                }
                
                const chunk = file.slice(offset, offset + CHUNK_SIZE);
                const buffer = await chunk.arrayBuffer();
                conn.send(new Uint8Array(buffer)); // Send pure binary
                
                offset += CHUNK_SIZE;
                
                // Update UI
                const now = Date.now();
                if (now - lastUpdate > 500 || offset >= file.size) {
                    const duration = (now - startTime) / 1000;
                    const speed = duration > 0 ? (offset / duration) : 0;
                    const progress = Math.min(100, Math.floor((offset / file.size) * 100));
                    const speedStr = formatSpeed(speed);
                    
                    if (isChat) updateChatProgress(fileId, progress, speedStr);
                    else updateMainSendProgress(file.uiId, progress, speedStr);
                    
                    lastUpdate = now;
                }
            }
            
            conn.send({ type: 'end' });
            
            // Local Preview
            if (isChat) {
                const url = URL.createObjectURL(file);
                finishFileBubble(fileId, url, file.name, file.type, true);
            } else {
                updateMainSendProgress(file.uiId, 100, "Done");
            }
        }

        function generateUUID() { return Date.now().toString(36) + Math.random().toString(36).substr(2); }
        function formatSpeed(bytesPerSec) {
            if(bytesPerSec > 1024*1024) return (bytesPerSec / (1024*1024)).toFixed(1) + " MB/s";
            return (bytesPerSec / 1024).toFixed(1) + " KB/s";
        }

        // --- UI Updating (Main List) ---
        function addReceiveListItem(name, id) {
            const li = document.createElement('li');
            li.className = 'file-item';
            li.id = `rx-${id}`;
            li.innerHTML = `
                <div class="file-name">${name}</div>
                <div class="file-status">Receiving...</div>
            `;
            ui.receive.list.prepend(li);
        }
        function updateMainListProgress(id, pct, speed) {
            const li = document.getElementById(`rx-${id}`);
            if(li) li.querySelector('.file-status').innerText = `${pct}% ‚Ä¢ ${speed}`;
        }
        function finishReceiveListItem(id, url, name) {
            const li = document.getElementById(`rx-${id}`);
            if(li) {
                li.classList.add('done');
                li.innerHTML = `
                    <div class="file-name">${name}</div>
                    <a href="${url}" download="${name}" class="download-btn">üì• Save</a>
                `;
            }
        }
        function updateMainSendProgress(uiId, pct, speed) {
            const li = document.getElementById(uiId);
            if(li) li.querySelector('.file-status').innerText = pct === 100 ? "‚úÖ Sent" : `${pct}% ‚Ä¢ ${speed}`;
        }

        // --- Chat UI Functions ---
        function createFileBubble(id, name, sender) {
            const div = document.createElement('div'); div.className = `message msg-${sender}`; div.id = `bubble-${id}`;
            div.innerHTML = `<div class="file-bubble"><div class="file-bubble-info"><span>üìÑ ${name}</span></div><div class="chat-progress-bg"><div class="chat-progress-fill" style="width:0%"></div></div><div class="file-meta">Waiting...</div></div>`;
            ui.chatMessages.appendChild(div); ui.chatMessages.scrollTop = ui.chatMessages.scrollHeight;
        }
        function updateChatProgress(id, pct, speedStr) {
            const bubble = document.getElementById(`bubble-${id}`);
            if (bubble) {
                bubble.querySelector('.chat-progress-fill').style.width = pct + "%";
                bubble.querySelector('.file-meta').innerText = `${pct}% ‚Ä¢ ${speedStr}`;
            }
        }
        function finishFileBubble(id, url, name, type, isSender) {
            const bubble = document.getElementById(`bubble-${id}`); if (!bubble) return;
            if (type.startsWith('image/') && url) {
                bubble.innerHTML = `<img src="${url}" class="msg-img" onclick="openLightbox('${url}')">`;
            } else {
                bubble.innerHTML = isSender 
                    ? `<div class="file-bubble-info" style="opacity:0.8"><span>‚úÖ Sent: ${name}</span></div>` 
                    : `<div class="file-bubble-info" onclick="saveChatFile('${url}', '${name}')" style="cursor:pointer; color:#2C3E50; background:#fff; padding:8px; border-radius:8px;"><span>üì• Tap to Save: ${name}</span></div>`;
            }
        }
        window.saveChatFile = (url, name) => { const a = document.createElement('a'); a.href = url; a.download = name; a.click(); };
        function openLightbox(src) { ui.lightboxImg.src = src; ui.lightbox.style.display = 'flex'; }

        // --- Queue Management ---
        function handleFileSelect(input) { if(input.files.length) { for(let f of input.files) sendQueue.push(f); updateQueueUI(); } }
        function handleChatFileSelect(input) { if(input.files.length) { for(let f of input.files) transferFileUnified(f, true); } }
        
        function updateQueueUI() { 
            ui.send.list.innerHTML = ""; 
            sendQueue.forEach((f, i) => { 
                // Assign UI ID to file object
                f.uiId = `q-${i}`;
                const li = document.createElement('li'); li.className = 'file-item'; li.id = f.uiId; 
                li.innerHTML = `<span class="file-name">${f.name}</span><span class="file-status">Wait</span>`; 
                ui.send.list.appendChild(li); 
            }); 
            ui.send.btn.style.display = 'block'; ui.send.btn.innerText = `Send ${sendQueue.length} Files`;
        }
        
        async function processQueue() { 
            if(!conn || !sendQueue.length) return; 
            ui.send.btn.style.display = 'none'; requestWakeLock(); 
            for(let i=0; i<sendQueue.length; i++) { 
                const li = document.getElementById(sendQueue[i].uiId);
                if(li) { li.style.fontWeight = 'bold'; li.querySelector('.file-status').innerText = "Starting..."; }
                await transferFileUnified(sendQueue[i], false); 
                if(li) li.classList.add('done');
            } 
            showToast("All Sent!"); releaseWakeLock(); sendQueue=[]; 
        }

        // --- Friends & Standard Logic (Same as V2.1) ---
        function getFriends() { return JSON.parse(localStorage.getItem('mochi_friends') || '[]'); }
        function isFriend(id) { return getFriends().some(f => f.id === id); }
        function saveCurrentFriend() { if (!currentConnectedPeerId || isFriend(currentConnectedPeerId)) return; const name = prompt("Name this device:", "New Device"); if (name) { const f = getFriends(); f.push({ id: currentConnectedPeerId, name: name }); localStorage.setItem('mochi_friends', JSON.stringify(f)); ui.btnSave.innerText = "‚úÖ Saved"; renderFriendsList(); } }
        function deleteFriend(id, e) { e.stopPropagation(); if(confirm("Remove?")) { localStorage.setItem('mochi_friends', JSON.stringify(getFriends().filter(f => f.id !== id))); renderFriendsList(); } }
        function renderFriendsList() { const f = getFriends(); ui.friendsList.innerHTML = f.length ? '' : '<li style="text-align:center;padding:10px;color:#999">No saved devices</li>'; f.forEach(fr => { const li = document.createElement('li'); li.className = 'friend-item'; li.id=`fr-${fr.id}`; li.onclick=()=>connectToSaved(fr.id); li.innerHTML=`<span style="margin-right:10px">üë§</span><span class="friend-name">${fr.name}</span><button class="btn-icon-small" onclick="deleteFriend('${fr.id}', event)">‚úï</button>`; ui.friendsList.appendChild(li); }); if(currentConnectedPeerId) updateFriendStatus(currentConnectedPeerId, true); }
        function updateFriendStatus(id, online) { const el = document.getElementById(`fr-${id}`); if(el) online ? el.classList.add('active') : el.classList.remove('active'); }
        function connectToSaved(id) { ui.input.value = id; connectToFriend(); }
        
        const emojis = ["üòÄ","üòÇ","üòç","üò≠","üëç","üôè","üéâ","‚ù§Ô∏è","ü§î","üòé","üëã","üî•"];
        emojis.forEach(e => { let span = document.createElement('div'); span.className = 'emoji-item'; span.innerText = e; span.onclick = () => { ui.chatInput.value += e; ui.chatInput.focus(); }; ui.emojiPicker.appendChild(span); });
        function toggleChat() { const isHidden = ui.chatModal.style.display === 'none'; ui.chatModal.style.display = isHidden ? 'flex' : 'none'; if (isHidden) { ui.fabToast.style.display = 'none'; document.getElementById('fab-chat').classList.remove('animate-pulse'); ui.chatInput.focus(); } }
        function toggleEmoji() { ui.emojiPicker.style.display = ui.emojiPicker.style.display === 'grid' ? 'none' : 'grid'; }
        ui.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendTextMessage(); } });
        function sendTextMessage() { const text = ui.chatInput.value.trim(); if (!text || !conn) return; conn.send({ type: 'chat-text', text: text }); appendMessage(text, 'self'); ui.chatInput.value = ""; ui.emojiPicker.style.display = 'none'; }
        function appendMessage(content, sender, isImage = false) { const div = document.createElement('div'); div.className = `message msg-${sender}`; if (isImage) div.innerHTML = `<img src="${content}" class="msg-img" onclick="openLightbox('${content}')">`; else div.innerText = content; ui.chatMessages.appendChild(div); ui.chatMessages.scrollTop = ui.chatMessages.scrollHeight; }
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(e => { ui.dropZone.addEventListener(e, pd); ui.chatMessages.addEventListener(e, pd); });
        function pd(e) { e.preventDefault(); e.stopPropagation(); }
        ui.dropZone.addEventListener('drop', e => handleDrop(e, false)); ui.chatMessages.addEventListener('drop', e => handleDrop(e, true));
        async function handleDrop(e, fromChat) { let dt = e.dataTransfer; if (dt.files.length) { for (let i = 0; i < dt.files.length; i++) { if(fromChat) transferFileUnified(dt.files[i], true); else { sendQueue.push(dt.files[i]); updateQueueUI(); } } } }
        function startScan() { ui.scan.overlay.style.display = "flex"; html5QrCode = new Html5Qrcode("reader"); html5QrCode.start({ facingMode: "environment" }, { fps: 30, qrbox: { width: 250, height: 250 } }, t => { ui.input.value = t; stopScan(); showToast("Scanned"); }, () => {}).catch(() => { showToast("Camera Error"); stopScan(); }); }
        function stopScan() { if(html5QrCode?.isScanning) html5QrCode.stop().then(() => { html5QrCode.clear(); ui.scan.overlay.style.display = "none"; }); else ui.scan.overlay.style.display = "none"; }
        function connectToFriend() { const id = ui.input.value.trim(); if(!id) return showToast("Enter ID"); conn = peer.connect(id, { reliable: true }); showToast("Connecting..."); setupConnection(); }
        async function requestWakeLock() { try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
        function releaseWakeLock() { if (wakeLock) { wakeLock.release(); wakeLock = null; } }
        function showToast(t) { ui.toast.innerText = t; ui.toast.style.display = 'block'; ui.toast.style.animation = 'pop 0.3s ease'; setTimeout(()=>ui.toast.style.display='none',3000); }
    </script>
</body>
</html>
