<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#F7F9F7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>MochiDrop ğŸ¦¥ V7.0</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="https://cdn-icons-png.flaticon.com/512/3750/3750019.png">
    
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Quicksand:wght@500;600;700&display=swap');
        
        :root {
            --primary: #76A665; --bg: #F7F9F7; --card-bg: #FFF; --text: #2C3E50; --grey: #95A5A6;
            --bubble-self: #76A665; --bubble-friend: #FFFFFF;
        }

        * { box-sizing: border-box; }
        body { font-family: 'Quicksand', sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding-top: 70px; padding-bottom: 40px; -webkit-tap-highlight-color: transparent; }

        .navbar { position: fixed; top: 0; left: 0; width: 100%; height: 60px; background: rgba(247,249,247,0.95); backdrop-filter: blur(10px); display: flex; align-items: center; justify-content: center; z-index: 1000; box-shadow: 0 1px 0 rgba(0,0,0,0.05); }
        .navbar-title { font-family: 'Fredoka One', cursive; color: var(--primary); font-size: 1.4rem; display: flex; align-items: center; gap: 8px; }
        
        .card { width: 90%; max-width: 420px; background: #FFF; border-radius: 20px; padding: 20px; box-shadow: 0 5px 20px rgba(0,0,0,0.05); margin-bottom: 20px; }
        .card-label { font-size: 0.75rem; color: var(--grey); font-weight: 700; letter-spacing: 1px; margin-bottom: 15px; display: block; text-align: left; }
        
        /* èº«ä»½ & è¿æ¥ */
        .identity-row { display: flex; align-items: center; gap: 15px; }
        #qrcode { background: #F0F2F0; border-radius: 12px; padding: 5px; display: inline-block; }
        #qrcode img { display: block; }
        .id-text { font-family: monospace; font-size: 1.1rem; font-weight: 700; word-break: break-all; }
        .status-dot { width: 10px; height: 10px; background: #ccc; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-dot.online { background: var(--primary); animation: pulse 2s infinite; }
        
        .input-group { display: flex; background: #F0F2F0; border-radius: 12px; padding: 5px; margin-bottom: 10px; }
        input[type="text"] { flex: 1; border: none; background: transparent; padding: 10px; font-size: 1rem; outline: none; text-align: center; }
        .btn-main { width: 100%; padding: 14px; background: var(--primary); color: white; border: none; border-radius: 12px; font-weight: 700; font-size: 1rem; cursor: pointer; transition: 0.2s; }
        .btn-main:active { transform: scale(0.98); opacity: 0.9; }
        .btn-icon-sm { background: none; border: none; font-size: 1.2rem; cursor: pointer; padding: 0 10px; }

        /* ä¼ è¾“åˆ—è¡¨ */
        .upload-area { border: 2px dashed #C1D1BE; border-radius: 16px; padding: 40px 20px; text-align: center; cursor: pointer; background: #FAFCFA; transition: 0.3s; }
        .upload-area.drag-over { background: #E8F5E9; border-color: var(--primary); transform: scale(1.02); }
        
        .file-list { list-style: none; padding: 0; margin: 15px 0; max-height: 400px; overflow-y: auto; }
        .file-item { background: #FFF; border: 1px solid #EEE; padding: 12px; border-radius: 12px; margin-bottom: 10px; display: flex; align-items: center; gap: 12px; }
        .file-info { flex: 1; overflow: hidden; }
        .file-name { font-size: 0.9rem; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; text-align: left; }
        .file-meta { font-size: 0.75rem; color: #888; display: flex; justify-content: space-between; margin-top: 4px; font-family: monospace; }
        .progress-bg { height: 4px; background: #EEE; border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--primary); width: 0%; transition: width 0.2s; }
        .file-action { font-size: 1.2rem; cursor: pointer; color: var(--primary); }

        /* èŠå¤©çª—å£ */
        #fab-chat { position: fixed; bottom: 30px; right: 30px; width: 60px; height: 60px; background: var(--primary); border-radius: 50%; color: white; border: none; font-size: 1.8rem; box-shadow: 0 5px 20px rgba(118,166,101,0.4); display: none; align-items: center; justify-content: center; z-index: 2000; cursor: pointer; }
        #chat-modal { position: fixed; bottom: -100%; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 3000; transition: bottom 0.3s; display: flex; align-items: flex-end; justify-content: center; }
        #chat-modal.visible { bottom: 0; }
        .chat-box { width: 100%; max-width: 500px; height: 85vh; background: #F2F4F2; border-radius: 20px 20px 0 0; display: flex; flex-direction: column; overflow: hidden; }
        .chat-header { padding: 15px; background: #FFF; display: flex; justify-content: space-between; align-items: center; font-weight: 700; border-bottom: 1px solid #EEE; }
        .chat-body { flex: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .msg { max-width: 80%; padding: 10px 14px; border-radius: 16px; font-size: 0.95rem; line-height: 1.4; word-break: break-word; position: relative; }
        .msg.self { align-self: flex-end; background: var(--primary); color: white; border-bottom-right-radius: 2px; }
        .msg.friend { align-self: flex-start; background: #FFF; color: #333; border-bottom-left-radius: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        .msg-img { max-width: 200px; border-radius: 8px; margin-top: 5px; cursor: zoom-in; display: block; background: #eee; }
        .chat-footer { padding: 10px; background: #FFF; border-top: 1px solid #EEE; display: flex; gap: 10px; align-items: center; }
        .chat-input { flex: 1; padding: 10px; background: #F5F5F5; border: none; border-radius: 20px; outline: none; }
        
        /* è°ƒè¯•ä¸è¾…åŠ© */
        #debug-log { position: fixed; top: 70px; left: 10px; font-size: 10px; color: #999; pointer-events: none; z-index: 500; display: none; }
        #toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%); background: #333; color: #FFF; padding: 10px 20px; border-radius: 30px; display: none; z-index: 5000; white-space: nowrap; }
        #scan-overlay { position: fixed; inset: 0; background: #000; z-index: 4000; display: none; }
        #reader { width: 100%; height: 100%; }
        #lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 6000; display: none; align-items: center; justify-content: center; }
        #lightbox img { max-width: 95%; max-height: 95%; border-radius: 5px; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
    </style>
</head>
<body onclick="unlockAudio()">

    <audio id="silent-audio" loop><source src="data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//oeAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAEAAABIADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD//////////////////////////////////////////////////////////////////wAAAP//OgAAAAAAAABMYXZjNTguMTM0LjEwMAAAAAAAAAAAAAAA//oeAAAAAAABIAAAAAAAAAAAAAAA//oeAAAAAAAAAAAAAAAAAAAAAAA=" type="audio/mpeg"></audio>
    
    <div id="debug-log"></div>

    <div class="navbar">
        <div class="navbar-title"><img src="https://cdn-icons-png.flaticon.com/512/3750/3750019.png" width="30"> SlothDrop</div>
    </div>

    <div class="card" id="identity-panel">
        <span class="card-label">MY IDENTITY</span>
        <div class="identity-row">
            <div id="qrcode"></div>
            <div>
                <div class="id-text" id="my-id">Connecting...</div>
                <div style="margin-top:5px; font-size:0.85rem; color:#666;">
                    <span class="status-dot" id="status-dot"></span><span id="status-text">Init...</span>
                </div>
            </div>
        </div>
    </div>

    <div class="card" id="connect-panel">
        <span class="card-label">CONNECT</span>
        <div class="input-group">
            <input type="text" id="friend-id" placeholder="Enter ID">
            <button class="btn-icon-sm" onclick="startScan()">ğŸ“·</button>
        </div>
        <button class="btn-main" onclick="connectToFriend()">Connect Now</button>
    </div>

    <div class="card" id="transfer-panel" style="display:none;">
        <span class="card-label">TRANSFER (Drag & Drop Ready)</span>
        
        <label class="upload-area" id="drop-zone">
            <div style="font-size:2rem; margin-bottom:10px;">ğŸ“‚</div>
            <div>Click or Drag Files/Folders</div>
        </label>
        <input type="file" id="file-input" multiple style="display:none" onchange="handleFiles(this.files, 'main')">
        
        <ul class="file-list" id="main-file-list"></ul>
    </div>

    <button id="fab-chat" onclick="toggleChat()">ğŸ’¬</button>

    <div id="chat-modal">
        <div class="chat-box">
            <div class="chat-header">
                <span>ğŸ’¬ Chat</span>
                <span onclick="toggleChat()" style="cursor:pointer; padding:10px;">âœ•</span>
            </div>
            <div class="chat-body" id="chat-body">
                <div style="text-align:center; color:#AAA; font-size:0.8rem; margin-top:20px;">Connection Established.</div>
            </div>
            <div class="chat-footer">
                <button class="btn-icon-sm" onclick="document.getElementById('chat-file-in').click()">ğŸ“</button>
                <input type="text" class="chat-input" id="chat-input" placeholder="Message..." autocomplete="off">
                <button class="btn-icon-sm" style="color:var(--primary)" onclick="sendText()">â¤</button>
                <input type="file" id="chat-file-in" multiple style="display:none" onchange="handleFiles(this.files, 'chat')">
            </div>
        </div>
    </div>

    <div id="toast">Msg</div>
    <div id="lightbox" onclick="this.style.display='none'"><img id="lb-img"></div>
    <div id="scan-overlay"><button class="btn-main" style="position:absolute;top:20px;right:20px;width:auto;" onclick="stopScan()">Close</button><div id="reader"></div></div>

    <script>
        // --- V7.0 Architect Core ---
        let peer, conn;
        // ä½¿ç”¨ 16KB åˆ‡ç‰‡ï¼Œè¿™æ˜¯ WebRTC åœ¨ iOS å’Œ Android é—´æœ€ç¨³çš„æ•°å€¼
        const CHUNK_SIZE = 16384; 
        let fileQueue = [];
        let isSending = false;
        let pendingAck = null;

        const ui = {
            id: document.getElementById('my-id'),
            stat: document.getElementById('status-text'),
            dot: document.getElementById('status-dot'),
            mainList: document.getElementById('main-file-list'),
            chatBody: document.getElementById('chat-body'),
            toast: document.getElementById('toast')
        };

        // 1. åˆå§‹åŒ– PeerJS
        try {
            peer = new Peer(null, { debug: 1 });
            peer.on('open', id => {
                ui.id.innerText = id;
                ui.stat.innerText = "Online";
                ui.dot.classList.add('online');
                new QRCode(document.getElementById("qrcode"), { text: id, width: 80, height: 80 });
                log("Peer Ready: " + id);
            });
            peer.on('connection', c => { conn = c; setupConnection(); });
            peer.on('error', e => showToast("Error: " + e.type));
        } catch(e) { alert("Init Failed"); }

        function connectToFriend() {
            const id = document.getElementById('friend-id').value.trim();
            if(!id) return showToast("Enter ID");
            log("Connecting to " + id);
            conn = peer.connect(id, { reliable: true });
            setupConnection();
        }

        function setupConnection() {
            conn.on('open', () => {
                showToast("Connected!");
                document.getElementById('connect-panel').style.display = 'none';
                document.getElementById('transfer-panel').style.display = 'block';
                document.getElementById('fab-chat').style.display = 'flex';
                ui.stat.innerText = "Linked";
                log("Connection Open");
            });
            conn.on('close', () => { showToast("Disconnected"); setTimeout(()=>location.reload(), 1000); });
            conn.on('data', handleData);
        }

        // 2. æ¥æ”¶æ•°æ®æ ¸å¿ƒ (çŠ¶æ€æœº)
        let rx = { buf: [], size: 0, meta: null, id: null, start: 0, lastUp: 0 };

        function handleData(data) {
            // A. äºŒè¿›åˆ¶æ•°æ® (æ–‡ä»¶å†…å®¹)
            if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
                if (!rx.meta) return; // ä¸¢å¼ƒå­¤å„¿æ•°æ®
                
                const chunk = new Uint8Array(data);
                rx.buf.push(chunk);
                rx.size += chunk.byteLength;
                
                const now = Date.now();
                if (now - rx.lastUp > 500 || rx.size === rx.meta.size) {
                    const speed = calcSpeed(rx.size, rx.start);
                    const pct = Math.floor((rx.size / rx.meta.size) * 100);
                    updateUI(rx.id, pct, speed, rx.meta.mode);
                    rx.lastUp = now;
                }
            }
            // B. æ§åˆ¶ä¿¡ä»¤
            else if (data.type) {
                log("Recv Signal: " + data.type);
                if (data.type === 'header') {
                    // 1. åˆå§‹åŒ–æ¥æ”¶
                    rx.buf = []; rx.size = 0; rx.meta = data; rx.id = data.id; rx.start = Date.now();
                    createUI(data.id, data.name, data.size, data.mode, 'in');
                    
                    // 2. å…³é”®ä¿®å¤ï¼šå‘é€ ACK ç¡®è®¤æ¡æ‰‹
                    conn.send({ type: 'ack', id: data.id });
                    
                    if(data.mode === 'chat' && !document.getElementById('chat-modal').classList.contains('visible')) showToast("New File!");
                }
                else if (data.type === 'ack') {
                    // å‘é€æ–¹æ”¶åˆ°ç¡®è®¤ï¼Œè§£é”å‘é€é˜Ÿåˆ—
                    if (pendingAck && pendingAck.id === data.id) pendingAck.resolve();
                }
                else if (data.type === 'end') {
                    // 3. æ¥æ”¶å®Œæˆï¼Œç”Ÿæˆæ–‡ä»¶
                    const blob = new Blob(rx.buf, { type: rx.meta.mime || 'application/octet-stream' });
                    const url = URL.createObjectURL(blob);
                    
                    finishUI(rx.id, url, rx.meta.name, rx.meta.mime, rx.meta.mode, 'in');
                    rx.buf = []; rx.meta = null;
                }
                else if (data.type === 'chat') {
                    addChatMsg(data.text, 'friend');
                    if(!document.getElementById('chat-modal').classList.contains('visible')) showToast("New Message");
                }
            }
        }

        // 3. å‘é€æ ¸å¿ƒ (å¸¦ ACK é‡è¯•æœºåˆ¶)
        function handleFiles(files, mode) {
            for (let f of files) {
                const id = Date.now() + Math.random().toString(16).slice(2);
                createUI(id, f.name, f.size, mode, 'out');
                fileQueue.push({ file: f, id: id, mode: mode });
            }
            processQueue();
        }

        async function processQueue() {
            if (isSending || fileQueue.length === 0) return;
            isSending = true;
            const job = fileQueue.shift();
            log("Start Sending: " + job.file.name);

            // 1. å°è¯•å‘é€ Header å¹¶ç­‰å¾… ACK
            let ackReceived = false;
            let attempts = 0;
            
            while (!ackReceived && attempts < 3) {
                conn.send({ type: 'header', name: job.file.name, size: job.file.size, mime: job.file.type, mode: job.mode, id: job.id });
                updateUI(job.id, 0, "Handshake...", job.mode);
                
                try {
                    // ç­‰å¾… 3 ç§’ ACKï¼Œè¶…æ—¶é‡è¯•
                    await new Promise((resolve, reject) => {
                        pendingAck = { id: job.id, resolve: resolve };
                        setTimeout(reject, 3000); 
                    });
                    ackReceived = true;
                } catch (e) {
                    attempts++;
                    log("ACK Timeout, Retrying...");
                }
            }

            if (!ackReceived) {
                showToast("Connection unstable, skip file.");
                updateUI(job.id, 0, "Failed", job.mode);
                isSending = false;
                processQueue();
                return;
            }

            // 2. æ¡æ‰‹æˆåŠŸï¼Œå…¨é€Ÿå‘é€
            let offset = 0;
            const start = Date.now();
            let lastUp = 0;

            // è¯»å–æ–‡ä»¶æµ
            const reader = new FileReader();
            
            // ä½¿ç”¨ Promise å°è£… FileReaderï¼Œé¿å…å›è°ƒåœ°ç‹±
            const readChunk = (start, end) => new Promise(resolve => {
                const slice = job.file.slice(start, end);
                reader.onload = e => resolve(e.target.result);
                reader.readAsArrayBuffer(slice);
            });

            while (offset < job.file.size) {
                // èƒŒå‹æ§åˆ¶ï¼šé˜²æ­¢æµè§ˆå™¨ç¼“å†²åŒºæº¢å‡º
                if (conn.dataChannel.bufferedAmount > 1024 * 1024) { // 1MB Buffer Limit
                    await new Promise(r => setTimeout(r, 10));
                    continue;
                }

                const buffer = await readChunk(offset, offset + CHUNK_SIZE);
                conn.send(new Uint8Array(buffer)); // å¼ºåˆ¶è½¬ Uint8Array å‘é€
                offset += CHUNK_SIZE;

                const now = Date.now();
                if (now - lastUp > 200 || offset >= job.file.size) {
                    const speed = calcSpeed(offset, start);
                    const pct = Math.floor((offset / job.file.size) * 100);
                    updateUI(job.id, pct, speed, job.mode);
                    lastUp = now;
                }
            }

            conn.send({ type: 'end' });
            
            // å‘é€æ–¹æœ¬åœ°é¢„è§ˆ
            const url = URL.createObjectURL(job.file);
            finishUI(job.id, url, job.file.name, job.file.type, job.mode, 'out');
            
            isSending = false;
            processQueue();
        }

        // 4. PC æ‹–æ‹½ä¿®å¤ (æ·±åº¦é€’å½’æ‰«æ)
        const dz = document.getElementById('drop-zone');
        dz.ondragover = e => { e.preventDefault(); dz.classList.add('drag-over'); };
        dz.ondragleave = () => dz.classList.remove('drag-over');
        dz.ondrop = async e => {
            e.preventDefault(); dz.classList.remove('drag-over');
            const items = e.dataTransfer.items;
            let files = [];
            
            // é€’å½’æ‰«æå‡½æ•°
            const scan = async (entry) => {
                if (entry.isFile) {
                    return new Promise(r => entry.file(f => r([f])));
                } else if (entry.isDirectory) {
                    const reader = entry.createReader();
                    const entries = await new Promise(r => reader.readEntries(r));
                    let subFiles = [];
                    for (let child of entries) subFiles = subFiles.concat(await scan(child));
                    return subFiles;
                }
                return [];
            };

            for (let i = 0; i < items.length; i++) {
                const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
                if (entry) files = files.concat(await scan(entry));
                else if (items[i].kind === 'file') files.push(items[i].getAsFile());
            }
            
            if (files.length > 0) handleFiles(files, 'main');
        };

        // 5. UI æ¸²æŸ“ç³»ç»Ÿ
        function createUI(id, name, size, mode, dir) {
            if (mode === 'main') {
                const li = document.createElement('li');
                li.className = 'file-item'; li.id = `ui-${id}`;
                li.innerHTML = `
                    <div style="font-size:1.5rem">${dir==='out'?'ğŸ“¤':'ğŸ“¥'}</div>
                    <div class="file-info">
                        <div class="file-name">${name}</div>
                        <div class="file-meta"><span class="state">Waiting...</span><span>${formatSize(size)}</span></div>
                        <div class="progress-bg"><div class="progress-fill" style="width:0%"></div></div>
                    </div>
                    <div class="file-action"></div>
                `;
                ui.mainList.prepend(li);
            } else {
                const div = document.createElement('div');
                div.className = `msg ${dir === 'out' ? 'self' : 'friend'}`;
                div.id = `ui-${id}`;
                div.innerHTML = `
                    <div class="bubble-file">
                        <div style="font-weight:600;font-size:0.9rem">ğŸ“„ ${name}</div>
                        <div class="progress-bg" style="margin-top:5px"><div class="progress-fill bubble-fill" style="width:0%"></div></div>
                        <div class="file-meta bubble-meta">Waiting...</div>
                    </div>
                `;
                ui.chatBody.appendChild(div);
                ui.chatBody.scrollTop = ui.chatBody.scrollHeight;
            }
        }

        function updateUI(id, pct, speed, mode) {
            const el = document.getElementById(`ui-${id}`);
            if (!el) return;
            const bar = el.querySelector(mode==='main' ? '.progress-fill' : '.bubble-fill');
            const txt = el.querySelector(mode==='main' ? '.state' : '.bubble-meta');
            if(bar) bar.style.width = pct + "%";
            if(txt) txt.innerText = pct < 100 ? `${pct}% â€¢ ${speed}` : "Finalizing...";
        }

        function finishUI(id, url, name, mime, mode, dir) {
            const el = document.getElementById(`ui-${id}`);
            if (!el) return;
            
            const isImg = mime && mime.startsWith('image/');
            
            if (mode === 'main') {
                el.querySelector('.progress-bg').style.display = 'none';
                el.querySelector('.state').innerText = "Done";
                if (dir === 'in') el.querySelector('.file-action').innerHTML = `<a href="${url}" download="${name}" style="text-decoration:none;font-size:1.5rem">ğŸ’¾</a>`;
                else el.querySelector('.file-action').innerText = "âœ…";
            } else {
                if (isImg) {
                    el.innerHTML = `<img src="${url}" class="msg-img" onclick="viewImg('${url}')">`;
                } else {
                    el.innerHTML = dir === 'in' 
                        ? `<div style="background:#FFF; padding:8px; border-radius:8px; color:#333; cursor:pointer" onclick="saveFile('${url}','${name}')">ğŸ“¥ Save: ${name}</div>`
                        : `<div style="opacity:0.8">âœ… Sent: ${name}</div>`;
                }
                ui.chatBody.scrollTop = ui.chatBody.scrollHeight;
            }
        }

        // è¾…åŠ©
        function calcSpeed(bytes, start) {
            const sec = (Date.now() - start) / 1000;
            return sec > 0 ? formatSize(bytes/sec) + "/s" : "";
        }
        function formatSize(b) { return b > 1048576 ? (b/1048576).toFixed(1)+" MB" : (b/1024).toFixed(0)+" KB"; }
        function log(msg) { console.log(msg); document.getElementById('debug-log').innerText = msg; }
        
        // Chat & Audio
        function toggleChat() { document.getElementById('chat-modal').classList.toggle('visible'); }
        document.getElementById('chat-input').onkeydown = e => { if(e.key === 'Enter') sendText(); };
        function sendText() {
            const t = document.getElementById('chat-input').value.trim();
            if(!t || !conn) return;
            conn.send({type:'chat', text:t});
            addChatMsg(t, 'self');
            document.getElementById('chat-input').value = "";
        }
        function addChatMsg(t, type) {
            const d = document.createElement('div'); d.className = `msg ${type}`; d.innerText = t;
            ui.chatBody.appendChild(d); ui.chatBody.scrollTop = ui.chatBody.scrollHeight;
        }
        function startScan() { document.getElementById('scan-overlay').style.display='block'; html5QrCode = new Html5Qrcode("reader"); html5QrCode.start({facingMode:"environment"}, {fps:10,qrbox:250}, t=>{ document.getElementById('friend-id').value=t; stopScan(); }, null); }
        function stopScan() { html5QrCode?.stop(); document.getElementById('scan-overlay').style.display='none'; }
        window.viewImg = u => { document.getElementById('lb-img').src=u; document.getElementById('lightbox').style.display='flex'; };
        window.saveFile = (u,n) => { const a=document.createElement('a'); a.href=u; a.download=n; a.click(); };
        function showToast(t) { const e=document.getElementById('toast'); e.innerText=t; e.style.display='block'; setTimeout(()=>e.style.display='none',3000); }
        function unlockAudio() { document.getElementById('silent-audio').play().catch(()=>{}); document.body.onclick=null; }
    </script>
</body>
</html>
